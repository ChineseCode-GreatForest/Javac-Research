#
# @(#)compiler_zh_CN.properties	1.13 07/03/21
# 
# Copyright (c) 2007 Sun Microsystems, Inc.  All Rights Reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#   
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.
#   
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#  
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#   
# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
# CA 95054 USA or visit www.sun.com if you need additional information or
# have any questions.
#  
#

##
## errors
##

compiler.err.abstract.cant.be.instantiated=\
{0} 是抽象的；无法对其进行实例化
compiler.err.abstract.meth.cant.have.body=\
抽象方法不能有主体
compiler.err.already.annotated=\
{0} {1} 已被注释
compiler.err.already.defined=\
已在 {1} 中定义 {0}
compiler.err.already.defined.single.import=\
已在 single-type 导入中定义 {0}
compiler.err.already.defined.static.single.import=\
已在静态 single-type 导入中定义 {0}
compiler.err.already.defined.this.unit=\
已在该编译单元中定义 {0}
compiler.err.annotation.missing.default.value=\
注释 {0} 缺少 {1}
compiler.err.annotation.not.valid.for.type=\
对于类型为 {0} 的值，注释无效
compiler.err.annotation.type.not.applicable=\
注释类型不适用于该类型的声明
compiler.err.annotation.value.must.be.annotation=\
注释值必须为注释
compiler.err.annotation.value.must.be.class.literal=\
注释值必须为类字面值
compiler.err.annotation.value.must.be.name.value=\
    注释值必须为以下格式：“name=value”
compiler.err.annotation.value.not.allowable.type=\
注释值不是允许的类型
compiler.err.anon.class.impl.intf.no.args=\
匿名类实现接口；不能有参数
compiler.err.anon.class.impl.intf.no.typeargs=\
匿名类实现接口；不能具有类型参数
compiler.err.anon.class.impl.intf.no.qual.for.new=\
匿名类实现接口；不能有限定符 - 对于新
compiler.err.array.and.varargs=\
无法在 {2} 中同时声明 {0} 和 {1}
compiler.err.array.dimension.missing=\
缺少数组维数
compiler.err.array.req.but.found=\
需要数组，但找到 {0}

compiler.err.assignment.from.super-bound=\
通过通配符 {0} 指定
compiler.err.assignment.to.extends-bound=\
指定给通配符 {0}
compiler.err.attribute.value.must.be.constant=\
属性值必须为常量

compiler.err.break.outside.switch.loop=\
在 switch 或 loop 外部中断

compiler.err.call.must.be.first.stmt.in.ctor=\
对 {0} 的调用必须是构造函数中的第一个语句
compiler.err.cant.apply.symbol=\
无法将 {1} 中的 {0} 应用于 {2}({3})
compiler.err.cant.apply.symbol.1=\
无法将 {1} 中的 {0} 应用于 {2}({3})；{4}
compiler.err.cant.assign.val.to.final.var=\
无法为最终变量 {0} 指定值
compiler.err.cant.deref=\
无法取消引用 {0}
compiler.err.cant.extend.intf.annotation=\
对于 @interface，不允许 "extends"
compiler.err.cant.inherit.from.final=\
无法从最终 {0} 进行继承
compiler.err.cant.ref.before.ctor.called=\
无法在调用父类型构造函数之前引用 {0}
compiler.err.cant.ret.val.from.meth.decl.void=\
对于结果类型为 void 的方法，无法返回值
compiler.err.cant.select.static.class.from.param.type=\
无法从参数化的类型中选择静态类
compiler.err.cant.inherit.diff.arg=\
无法使用以下不同的参数继承 {0}：<{1}> 和 <{2}>
compiler.err.catch.without.try=\
"catch" 不带有 "try"
compiler.err.clash.with.pkg.of.same.name=\
{0} 与带有相同名称的软件包冲突
compiler.err.const.expr.req=\
需要常量表达式
compiler.err.enum.const.req=\
需要非限定枚举常量名称
compiler.err.cont.outside.loop=\
continue 在 loop 外部
compiler.err.cyclic.inheritance=\
循环继承涉及 {0}
compiler.err.cyclic.annotation.element=\
循环注释元素类型
compiler.err.call.to.super.not.allowed.in.enum.ctor=\
在枚举构造函数中不允许调用父类型
compiler.err.no.superclass=\
{0} 不具有父类

compiler.err.concrete.inheritance.conflict=\
{1} 中的方法 {0} 和 {3} 中的方法 {2} 是使用相同的签名继承的

compiler.err.default.allowed.in.intf.annotation.member=\
仅在 @interface 成员中允许使用默认值
compiler.err.doesnt.exist=\
软件包 {0} 不存在
compiler.err.duplicate.annotation=\
注释重复
compiler.err.duplicate.annotation.member.value=\
{1} 中的注释成员值 {0} 重复
compiler.err.duplicate.class=\
类重复： {0}
compiler.err.duplicate.case.label=\
case 标签重复
compiler.err.duplicate.default.label=\
default 标签重复

compiler.err.else.without.if=\
"else" 不带有 "if"
compiler.err.empty.char.lit=\
空字符字面值
compiler.err.encl.class.required=\
需要包含 {0} 的封闭实例
compiler.err.enum.annotation.must.be.enum.constant=\
枚举注释值必须是枚举常量

compiler.err.enum.cant.be.instantiated=\
无法实例化枚举类型
compiler.err.enum.label.must.be.unqualified.enum=\
枚举 switch case 标签必须为枚举常量的非限定名称
compiler.err.enum.no.subclassing=\
类无法直接继承 java.lang.Enum
compiler.err.enum.types.not.extensible=\
枚举类型不可继承
compiler.err.enum.no.finalize=\
枚举不能有 finalize 方法
compiler.err.error.reading.file=\
读取 {0} 时出错；{1}
compiler.err.except.already.caught=\
已捕捉到异常 {0}
compiler.err.except.never.thrown.in.try=\
在相应的 try 语句主体中不能抛出异常 {0}

compiler.err.final.parameter.may.not.be.assigned=\
不能指定最终参数 {0}
compiler.err.finally.without.try=\
"finally" 不带有 "try"
compiler.err.foreach.not.applicable.to.type=\
foreach 不适用于表达式类型
compiler.err.fp.number.too.large=\
浮点数过大
compiler.err.fp.number.too.small=\
浮点数过小

compiler.err.generic.array.creation=\
创建泛型数组
compiler.err.generic.throwable=\
泛型类无法继承 java.lang.Throwable

compiler.err.icls.cant.have.static.decl=\
内部类不能有静态声明
compiler.err.illegal.char=\
非法字符： \\{0}
compiler.err.illegal.char.for.encoding=\
编码 {0} 的不可映射字符
compiler.err.illegal.combination.of.modifiers=\
非法的修饰符组合：{0} 和 {1}
compiler.err.illegal.enum.static.ref=\
初始化程序中对静态字段的引用不合法
compiler.err.illegal.esc.char=\
非法转义字符
compiler.err.illegal.forward.ref=\
非法向前引用
compiler.warn.forward.ref=\
    先引用变量''{0}''，然后再对其初始化
compiler.err.illegal.generic.type.for.instof=\
instanceof 的泛型类型不合法
compiler.err.illegal.initializer.for.type=\
{0} 的初始化程序不合法
compiler.err.illegal.line.end.in.char.lit=\
字符字面值的行结尾不合法
compiler.err.illegal.nonascii.digit=\
非法的非 ASCII 数字
compiler.err.illegal.qual.not.icls=\
非法限定符；{0} 不是内部类
compiler.err.illegal.start.of.expr=\
非法的表达式开始
compiler.err.illegal.start.of.type=\
非法的类型开始
compiler.err.illegal.unicode.esc=\
非法的 Unicode 转义
compiler.err.import.requires.canonical=\
导入需要 {0} 的规范名称
compiler.err.improperly.formed.type.param.missing=\
类型的格式不正确，缺少某些参数
compiler.err.improperly.formed.type.inner.raw.param=\
类型的格式不正确，给出了普通类型的类型参数
compiler.err.incomparable.types=\
不可比较的类型：{0} 和 {1}
compiler.err.int.number.too.large=\
过大的整数： {0}
compiler.err.internal.error.cant.instantiate=\
内部错误；无法将位于 {1} 的 {0} 实例化为 ({2})
compiler.err.intf.annotation.members.cant.have.params=\
@interface 成员不能带有参数
compiler.err.intf.annotation.cant.have.type.params=\
@interface 不能带有类型参数
compiler.err.intf.annotation.members.cant.have.type.params=\
@interface 成员不能带有类型参数
compiler.err.intf.annotation.member.clash=\
    @interface 成员与 {1} 中的方法''{0}''冲突
compiler.err.intf.expected.here=\
此处需要接口
compiler.err.intf.meth.cant.have.body=\
接口方法不能带有主体
compiler.err.invalid.annotation.member.type=\
注释成员的类型无效
compiler.err.invalid.hex.number=\
十六进制数字必须包含至少一位十六进制数
compiler.err.invalid.meth.decl.ret.type.req=\
方法声明无效；需要返回类型

compiler.err.label.already.in.use=\
标签 {0} 已使用
compiler.err.local.var.accessed.from.icls.needs.final=\
从内部类中访问局部变量 {0}；需要被声明为最终类型
compiler.err.local.enum=\
枚举类型不能为本地类型

#
# limits.  We don't give the limits in the diagnostic because we expect
# them to change, yet we want to use the same diagnostic.  These are all
# detected during code generation.
#
compiler.err.limit.code=\
代码过长
compiler.err.limit.code.too.large.for.try.stmt=\
try 语句的代码过长
compiler.err.limit.dimensions=\
数组类型维数过多
compiler.err.limit.locals=\
局部变量过多
compiler.err.limit.parameters=\
参数过多
compiler.err.limit.pool=\
常量过多
compiler.err.limit.pool.in.class=\
类 {0} 中的常量过多
compiler.err.limit.stack=\
代码需要过多堆栈
compiler.err.limit.string=\
常量字符串过长
compiler.err.limit.string.overflow=\
对于常量池来说，字符串 \"{0}...\" 的 UTF8 表示过长

compiler.err.malformed.fp.lit=\
浮点字面值不规则
compiler.err.method.does.not.override.superclass=\
    方法不会覆盖或实现超类型的方法
compiler.err.missing.meth.body.or.decl.abstract=\
缺少方法主体，或声明抽象
compiler.err.missing.ret.stmt=\
缺少返回语句
compiler.err.missing.ret.val=\
缺少返回值
compiler.err.mod.not.allowed.here=\
此处不允许使用修饰符 {0}
compiler.err.intf.not.allowed.here=\
此处不允许使用接口
compiler.err.enums.must.be.static=\
只有在静态上下文中才允许使用枚举声明

compiler.err.name.clash.same.erasure=\
名称冲突：{0} 和 {1} 具有相同疑符
compiler.err.name.clash.same.erasure.no.override=\
名称冲突：{1} 中的 {0} 和 {3} 中的 {2} 具有相同疑符，但两者均不覆盖对方
compiler.err.name.reserved.for.internal.use=\
{0} 为内部使用保留
compiler.err.native.meth.cant.have.body=\
本机方法不能带有主体
compiler.err.neither.conditional.subtype=\
? 的不兼容类型：两者都不是对方的子类型\n\
第二个操作数： {0}\n\
第三个操作数： {1}
compiler.err.new.not.allowed.in.annotation=\
注释中不允许使用 "new"
compiler.err.no.annotation.member=\
{1} 中没有注释成员 {0}
compiler.err.no.encl.instance.of.type.in.scope=\
作用域中没有类型为 {0} 的封闭实例
compiler.err.no.intf.expected.here=\
此处不需要接口
compiler.err.no.match.entry=\
{0} 在 {1} 的条目中没有匹配项；需要 {2}
compiler.err.not.annotation.type=\
{0} 不是注释类型
compiler.err.not.def.access.class.intf.cant.access=\
{1} 中的 {0} 是在不可访问的类或接口中定义的
compiler.err.not.def.public.cant.access=\
{0} 在 {1} 中不是公共的；无法从外部软件包中对其进行访问
compiler.err.not.loop.label=\
不是 loop 标签： {0}
compiler.err.not.stmt=\
不是语句
compiler.err.not.encl.class=\
不是封闭类： {0}

compiler.err.operator.cant.be.applied=\
运算符 {0} 不能应用于 {1}

compiler.err.pkg.annotations.sb.in.package-info.java=\
软件包注释应在文件 package-info.java 中
compiler.err.pkg.clashes.with.class.of.same.name=\
软件包 {0} 与带有相同名称的类冲突

# Errors related to annotation processing

compiler.err.proc.cant.access=\
无法访问 {0}\n\
{1}\n\
有关详细信息，请参阅以下堆栈追踪。\n\
{2}

compiler.err.proc.cant.find.class=\
找不到“{0}”的类文件。

# Print a client-generated error message; assumed to be localized, no translation required
compiler.err.proc.messager=\
    {0}

compiler.err.proc.no.explicit.annotation.processing.requested=\
仅当显式请求注释处理时才接受类名称“{0}”

compiler.err.proc.processor.bad.option.name=\
    处理器"{1}"提供的选项名称"{0}"错误

compiler.err.proc.processor.cant.instantiate=\
无法实例化处理程序“{0}”的实例

compiler.err.proc.processor.constructor.error=\
构造处理程序对象 {0} 时抛出异常

compiler.err.proc.processor.not.found=\
未找到注释处理程序“{0}”

compiler.err.proc.processor.wrong.type=\
注释处理程序“{0}”未实现 javax.annotation.processing.Processor

compiler.err.proc.bad.config.file=\
服务配置文件不正确，或构造处理程序对象 {0} 时抛出异常

compiler.err.proc.cant.create.loader=\
无法为注释处理程序 {0} 创建类加载器

compiler.err.qualified.new.of.static.class=\
限定的新静态类

compiler.err.recursive.ctor.invocation=\
递归构造函数调用
compiler.err.ref.ambiguous=\
对 {0} 的引用不明确，{3} 中的 {1} {2} 和 {6} 中的 {4} {5} 都匹配
compiler.err.repeated.annotation.target=\
注释目标重复
compiler.err.repeated.interface=\
接口重复
compiler.err.repeated.modifier=\
修饰符重复
compiler.err.report.access=\
{0} 可以在 {2} 中访问 {1}
compiler.err.ret.outside.meth=\
返回外部方法

compiler.err.signature.doesnt.match.supertype=\
签名与 {0} 不匹配；不兼容的父类型
compiler.err.signature.doesnt.match.intf=\
签名与 {0} 不匹配；不兼容的接口
compiler.err.does.not.override.abstract=\
{0} 不是抽象的，并且未覆盖 {2} 中的抽象方法 {1}
compiler.err.source.cant.overwrite.input.file=\
写入源时出错；无法覆写输入文件 {0}
compiler.err.stack.sim.error=\
内部错误：{0} 中的堆栈 sim 错误
compiler.err.static.imp.only.classes.and.interfaces=\
仅从类和接口静态导入
compiler.err.synthetic.name.conflict=\
符号 {0} 与 {1} 中的 compiler-synthesized 符号冲突

compiler.err.throws.not.allowed.in.intf.annotation=\
@interface 成员中不允许使用 throws 子句
compiler.err.try.without.catch.or.finally=\
"try" 不带有 "catch" 或 "finally"
compiler.err.type.doesnt.take.params=\
类型 {0} 不带有参数
compiler.err.type.var.cant.be.deref=\
无法从类型变量中进行选择
compiler.err.type.var.may.not.be.followed.by.other.bounds=\
类型变量后面不能带有其他限制范围
compiler.err.type.var.more.than.once=\
类型变量 {0} 在 {1} 的结果类型中多次出现；必须对其进行实例化
compiler.err.type.var.more.than.once.in.result=\
类型变量 {0} 在 {1} 的类型中多次出现；必须对其进行实例化
compiler.err.types.incompatible.diff.ret=\
类型 {0} 和 {1} 不兼容；两者都定义了 {2}，但却带有不相关的返回类型

compiler.err.unclosed.char.lit=\
未结束的字符字面值
compiler.err.unclosed.comment=\
未结束的注释
compiler.err.unclosed.str.lit=\
未结束的字符串字面值
compiler.err.unknown.enum.constant=\
在类文件 {0} 中：未知的枚举常量 {1}.{2}
compiler.err.unsupported.encoding=\
不支持的编码： {0}
compiler.err.io.exception=\
读取源文件时出错： {0}
compiler.err.undef.label=\
未定义的标签： {0}
compiler.err.undetermined.type=\
无法确定 {0} 的类型参数
compiler.err.undetermined.type.1=\
无法确定 {0} 的类型参数；{1}
compiler.err.unreachable.stmt=\
无法访问的语句
compiler.err.initializer.must.be.able.to.complete.normally=\
初始化程序必须能够正常完成
compiler.err.unreported.exception.need.to.catch.or.throw=\
未报告的异常 {0}；必须对其进行捕捉或声明以便抛出
compiler.err.unreported.exception.default.constructor=\
默认构造函数中未报告的异常 {0}
compiler.err.unsupported.cross.fp.lit=\
该 VM 不支持十六进制浮点字面值
compiler.err.void.not.allowed.here=\
此处不允许使用 "void" 类型

compiler.err.wrong.number.type.args=\
类型变量数目错误；需要 {0}

compiler.err.var.might.already.be.assigned=\
可能已指定变量 {0}
compiler.err.var.might.not.have.been.initialized=\
可能尚未初始化变量 {0}
compiler.err.var.might.be.assigned.in.loop=\
可能在 loop 中指定了变量 {0}

# In the following string, {1} will always be the detail message from
# java.io.IOException.
compiler.err.class.cant.write=\
写入 {0} 时出错： {1}

# In the following string, {0} is the name of the class in the Java source.
# It really should be used two times..
compiler.err.class.public.should.be.in.file=\
类 {0} 是公共的，应在名为 {0}.java 的文件中声明

## All errors which do not refer to a particular line in the source code are
## preceded by this string.
compiler.err.error=\
错误：

# The following error messages do not refer to a line in the source code.
compiler.err.cant.read.file=\
无法读取： {0}

#####

# Fatal Errors

compiler.misc.fatal.err.no.java.lang=\
致命错误：在类路径或引导类路径中找不到软件包 java.lang
compiler.misc.fatal.err.cant.locate.meth=\
致命错误：找不到方法 {0}
compiler.misc.fatal.err.cant.locate.field=\
致命错误：找不到字段 {0}
compiler.misc.fatal.err.cant.locate.ctor=\
致命错误：找不到 {0} 的构造函数

#####

##
## miscellaneous strings
##

compiler.misc.source.unavailable=\
（源不可用）
compiler.misc.base.membership=\
您的所有基类都属于我们
compiler.misc.x.print.processor.info=\
    处理程序 {0} 与 {1} 匹配并返回 {2}。
compiler.misc.x.print.rounds=\
    循环 {0}:\n\t输入文件: {1}\n\t注释: {2}\n\t最后一个循环: {3}

#####

## The following string will appear before all messages keyed as:
## "compiler.note".
compiler.note.note=\
注意：

compiler.note.deprecated.filename=\
{0} 使用或覆盖了已过时的 API。
compiler.note.deprecated.plural=\
某些输入文件使用或覆盖了已过时的 API。
# The following string may appear after one of the above deprecation
# messages.
compiler.note.deprecated.recompile=\
要了解详细信息，请使用 -Xlint:deprecation 重新编译。

compiler.note.deprecated.filename.additional=\
{0} 还使用或覆盖了已过时的 API。
compiler.note.deprecated.plural.additional=\
某些输入文件还使用或覆盖了已过时的 API。

# Notes related to annotation processing

# Print a client-generated note; assumed to be localized, no translation required
compiler.note.proc.messager=\
    {0}

compiler.note.unchecked.filename=\
{0} 使用了未经检查或不安全的操作。
compiler.note.unchecked.plural=\
某些输入文件使用了未经检查或不安全的操作。
# The following string may appear after one of the above deprecation
# messages.
compiler.note.unchecked.recompile=\
要了解详细信息，请使用 -Xlint:unchecked 重新编译。

compiler.note.unchecked.filename.additional=\
{0} 还有未经检查或不安全的操作。
compiler.note.unchecked.plural.additional=\
某些输入文件还使用了未经检查或不安全的操作。

#####

compiler.misc.count.error=\
{0} 错误
compiler.misc.count.error.plural=\
{0} 错误
compiler.misc.count.warn=\
{0} 警告
compiler.misc.count.warn.plural=\
{0} 警告

## extra output when using -verbose (JavaCompiler)

compiler.misc.verbose.checking.attribution=\
[正在检查 {0}]
compiler.misc.verbose.parsing.done=\
[解析已完成时间 {0}ms]
compiler.misc.verbose.parsing.started=\
[解析开始时间 {0}]
compiler.misc.verbose.total=\
[总时间 {0}ms]
compiler.misc.verbose.wrote.file=\
[已写入 {0}]

## extra output when using -verbose (Retro)
compiler.misc.verbose.retro=\
[正在更新 {0}]
compiler.misc.verbose.retro.with=\
正在使用 {1} 更新 {0}
compiler.misc.verbose.retro.with.list=\
正在使用类型参数 {1}、父类型 {2} 和接口 {3} 更新 {0}

## extra output when using -verbose (code/ClassReader)
compiler.misc.verbose.loading=\
[正在装入 {0}]

compiler.misc.verbose.sourcepath=\
[源文件的搜索路径： {0}]

compiler.misc.verbose.classpath=\
[类文件的搜索路径： {0}]

## extra output when using -checkclassfile (code/ClassReader)
compiler.misc.ccf.found.later.version=\
类文件的版本高于预期： {0}
compiler.misc.ccf.unrecognized.attribute=\
无法识别的属性： {0}

## extra output when using -prompt (util/Log)
compiler.misc.resume.abort=\
继续(&R), 放弃(&A)>

#####

##
## warnings
##

## All warning messages are preceded by the following string.
compiler.warn.warning=\
警告：

compiler.warn.constant.SVUID=\
[serial] 在类 {0} 中 serialVersionUID 必须为常量

compiler.warn.dir.path.element.not.found=\
[path] 错误的路径元素 "{0}"：无此目录

compiler.warn.finally.cannot.complete=\
[finally] 无法正常完成 finally 子句

compiler.warn.has.been.deprecated=\
[deprecation] {1} 中的 {0} 已过时

compiler.warn.illegal.char.for.encoding=\
编码 {0} 的不可映射字符
compiler.warn.improper.SVUID=\
[serial] 在类 {0} 中必须将 serialVersionUID 声明为静态最终类型

compiler.warn.inexact.non-varargs.call=\
最后一个参数使用了不准确的变量类型的 varargs 方法的非 varargs 调用；\n\
对于 varargs 调用，应使用 {0}\n\
对于非 varargs 调用，应使用 {1}，这样也可以抑制此警告

compiler.warn.long.SVUID=\
[serial] 在类 {0} 中 serialVersionUID 必须为长整型

compiler.warn.missing.SVUID=\
[serial] 可序列化类 {0} 中没有 serialVersionUID 的定义

compiler.warn.override.varargs.missing=\
{0}；被覆盖的方法没有 "..."
compiler.warn.override.varargs.extra=\
{0}；覆盖的方法缺少 "..."
compiler.warn.override.bridge=\
{0}；被覆盖的方法为 bridge 方法

compiler.warn.pkg-info.already.seen=\
[package-info] 已找到软件包 {0} 的 package-info.java 文件
compiler.warn.path.element.not.found=\
[path] 错误的路径元素 "{0}"：无此文件或目录
compiler.warn.possible.fall-through.into.case=\
[fallthrough] 可能无法实现 case

compiler.warn.redundant.cast=\
[转换] 向 {0} 转换出现冗余

compiler.warn.position.overflow=\
行 {0} 处的位置编码溢出

compiler.warn.big.major.version=\
{0}: 主版本 {1} 比 {2} 新，此编译器支持最新的主版本。\n\
建议升级此编译器。

# Warnings related to annotation processing
compiler.warn.proc.package.does.not.exist=\
    软件包 {0} 不存在
compiler.warn.proc.file.reopening=\
尝试多次为“{0}”创建文件

compiler.warn.proc.type.already.exists=\
    具有类型''{0}''的文件已经存在于源路径或类路径中

compiler.warn.proc.type.recreate=\
尝试多次创建具有类型“{0}”的文件

compiler.warn.proc.illegal.file.name=\
无法创建带有非法名称“{0}”的文件。

compiler.warn.proc.file.create.last.round=\
将不对在最后一个循环中创建的类型为“{0}”的文件进行注释处理。

compiler.warn.proc.malformed.supported.string=\
处理程序“{1}”为支持的注释类型返回不规则的字符串“{0}”

compiler.warn.proc.annotations.without.processors=\
    没有处理程序要使用以下任何注释: {0}

compiler.warn.proc.processor.incompatible.source.version=\
    来自注释处理器"{1}"的受支持 source 版本"{0}"低于 -source"{2}"

compiler.warn.proc.proc-only.requested.no.procs=\
在未请求编译的情况下进行注释处理，但未找到处理程序。

compiler.warn.proc.use.implicit=\
注释处理不适用于隐式编译的文件。\n\
使用 -implicit 指定用于隐式编译的策略。

compiler.warn.proc.use.proc.or.implicit=\
注释处理不适用于隐式编译的文件。\n\
使用 -proc:none 禁用注释处理或使用 -implicit 指定用于隐式编译的策略。

# Print a client-generated warning; assumed to be localized, no translation required
compiler.warn.proc.messager=\
    {0}

compiler.warn.proc.unclosed.type.files=\
类型为“{0}”的文件未关闭；将不针对这些类型进行注释处理

compiler.warn.proc.unmatched.processor.options=\
    以下选项未被任何处理器识别："{0}"

compiler.warn.unchecked.assign=\
[unchecked] 未经检查的指定：将 {0} 指定给 {1}
compiler.warn.unchecked.assign.to.var=\
[unchecked] 对作为普通类型 {1} 的成员的变量 {0} 的指定未经检查
compiler.warn.unchecked.call.mbr.of.raw.type=\
[unchecked] 对作为普通类型 {1} 的成员的 {0} 的调用未经检查
compiler.warn.unchecked.cast.to.type=\
[unchecked] 对类型 {0} 的使用未经检查
compiler.warn.unchecked.meth.invocation.applied=\
[unchecked] 方法调用未经检查：{1} 中的 {0} 被应用于 {2}({3})
compiler.warn.unchecked.generic.array.creation=\
[unchecked] 对于 varargs 参数，类型 {0} 的泛型数组创建未经检查

compiler.warn.missing.deprecated.annotation=\
[dep-ann] 未使用 @Deprecated 对已过时的项目进行注释

compiler.warn.invalid.archive.file=\
[path] 以下路径中存在意外的文件: {0}

compiler.warn.unexpected.archive.file=\
[path] 以下归档文件存在意外的扩展名: {0}

compiler.warn.div.zero=\
[divzero] 除数为零

compiler.warn.empty.if=\
[空] if 之后没有语句

compiler.warn.annotation.method.not.found=\
无法找到类型为“{0}”的注释方法“{1}()”

compiler.warn.annotation.method.not.found.reason=\
无法找到类型为“{0}”的注释方法“{1}()”: {2}

#####

## The following are tokens which are non-terminals in the language. They should
## be named as JLS3 calls them when translated to the appropriate language.
compiler.misc.token.identifier=\
<标识符>
compiler.misc.token.character=\
<字符>
compiler.misc.token.string=\
<字符串>
compiler.misc.token.integer=\
<整型>
compiler.misc.token.long-integer=\
<长整型>
compiler.misc.token.float=\
<浮点型>
compiler.misc.token.double=\
<双精度型>
compiler.misc.token.bad-symbol=\
<错误符号>
compiler.misc.token.end-of-input=\
<输入结束>

## The argument to the following string will always be one of the following:
## 1. one of the above non-terminals
## 2. a keyword (JLS1.8)
## 3. a boolean literal (JLS3.10.3)
## 4. the null literal (JLS3.10.7)
## 5. a Java separator (JLS3.11)
## 6. an operator (JLS3.12)
##
## This is the only place these tokens will be used.
compiler.err.expected=\
需要 {0}
compiler.err.expected2=\
需要为 {0} 或 {1}
compiler.err.expected3=\
需要为 {0}、{1} 或 {2}

compiler.err.premature.eof=\
进行语法解析时已到达文件结尾

## The following are related in form, but do not easily fit the above paradigm.
compiler.err.dot.class.expected=\
需要 ".class"

## The argument to this string will always be either 'case' or 'default'.
compiler.err.orphaned=\
单个 {0}：

compiler.misc.anonymous.class=\
<匿名 {0}>

#####

compiler.err.cant.access=\
无法访问 {0}\n\
{1}

compiler.misc.bad.class.file.header=\
错误的类文件： {0}\n\
{1}\n\
请删除该文件或确保该文件位于正确的类路径子目录中。

## The following are all possible strings for the second argument ({1}) of the
## above strings.
compiler.misc.bad.class.signature=\
错误的类签名： {0}
compiler.misc.bad.enclosing.method=\
闭合方法属性 {0} 时出错
compiler.misc.bad.runtime.invisible.param.annotations=\
    RuntimeInvisibleParameterAnnotations 属性错误: {0}
compiler.misc.bad.const.pool.tag=\
错误的常量池标记： {0}
compiler.misc.bad.const.pool.tag.at=\
错误的常量池标记：{0}，位于 {1}
compiler.misc.bad.signature=\
错误的签名： {0}
compiler.misc.class.file.wrong.class=\
类文件包含错误的类： {0}
compiler.misc.class.file.not.found=\
未找到 {0} 的类文件
compiler.misc.file.doesnt.contain.class=\
文件不包含类 {0}
compiler.misc.file.does.not.contain.package=\
    文件不包含软件包 {0}
compiler.misc.illegal.start.of.class.file=\
非法的类文件开始
compiler.misc.unable.to.access.file=\
无法访问文件： {0}
compiler.misc.unicode.str.not.supported=\
不支持类文件中的 Unicode 字符串
compiler.misc.undecl.type.var=\
未声明的类型变量： {0}
compiler.misc.wrong.version=\
类文件具有错误的版本 {0}.{1}，应为 {2}.{3}

#####

compiler.err.not.within.bounds=\
类型参数 {0} 不在其限制范围之内

compiler.err.not.within.bounds.explain=\
类型参数 {0} 不在其限制范围之内；{1}

## The following are all possible strings for the second argument ({1}) of the
## above string.

## none yet...

#####

compiler.err.prob.found.req=\
{0}\n\
找到： {1}\n\
需要： {2}
compiler.warn.prob.found.req=\
{0}\n\
找到： {1}\n\
需要： {2}
compiler.err.prob.found.req.1=\
{0} {3}\n\
找到： {1}\n\
需要： {2}

## The following are all possible strings for the first argument ({0}) of the
## above strings.
compiler.misc.incompatible.types=\
不兼容的类型
compiler.misc.incompatible.types.1=\
不兼容的类型；{0}
compiler.misc.inconvertible.types=\
不可转换的类型
compiler.misc.possible.loss.of.precision=\
可能损失精度

compiler.misc.unchecked.assign=\
[unchecked] 未经检查的转换
# compiler.misc.storecheck=\
#     [unchecked] assignment might cause later store checks to fail
# compiler.misc.unchecked=\
#     [unchecked] assigned array cannot dynamically check its stores
compiler.misc.unchecked.cast.to.type=\
[unchecked] 未经检查的类型使用

compiler.misc.assignment.from.super-bound=\
从 super-bound 类型 {0} 指定
compiler.misc.assignment.to.extends-bound=\
对 extends-bound 类型 {0} 进行指定
# compiler.err.star.expected=\
#     ''*'' expected
# compiler.err.no.elem.type=\
#     \[\*\] cannot have a type

#####

compiler.err.type.found.req=\
意外的类型\n\
找到： {0}\n\
需要： {1}

## The following are all possible strings for the first argument ({0}) of the
## above string.
compiler.misc.type.req.class=\
类
compiler.misc.type.req.class.array=\
类或数组
compiler.misc.type.req.ref=\
引用
compiler.misc.type.req.exact=\
不带限制范围的类或接口
compiler.misc.type.parameter=\
类型参数 {0} 

#####

## The following are all possible strings for the last argument of all those
## diagnostics whose key ends in ".1"
compiler.misc.undetermined.type=\
未确定的类型
ncompiler.misc.type.variable.has.undetermined.type=\
类型变量 {0} 带有未确定的类型
compiler.misc.no.unique.maximal.instance.exists=\
对于上限为 {1} 的类型变量 {0}，不存在唯一最大实例
compiler.misc.no.unique.minimal.instance.exists=\
对于下限为 {1} 的类型变量 {0}，不存在唯一最小实例
compiler.misc.no.conforming.instance.exists=\
不存在类型变量 {0} 的实例，以使 {1} 与 {2} 一致
compiler.misc.no.conforming.assignment.exists=\
不存在类型变量 {0} 的实例，以使参数类型 {1} 与形式参数类型 {2} 一致
compiler.misc.arg.length.mismatch=\
无法从参数进行实例化，因为实际参数列表和形式参数列表长度不同
compiler.misc.inferred.do.not.conform.to.bounds=\
推理类型参数 {0} 不符合类型变量 {1} 的限制范围

#####

## The first argument ({0}) is a "kindname".
compiler.err.abstract.cant.be.accessed.directly=\
无法直接访问 {2} 中的抽象 {0} {1}

## The first argument ({0}) is a "kindname".
compiler.err.non-static.cant.be.ref=\
无法从静态上下文中引用非静态 {0} {1}

## Both arguments ({0}, {1}) are "kindname"s.  {0} is a comma-separated list
## of kindnames (the list should be identical to that provided in source.
compiler.err.unexpected.type=\
意外的类型\n\
需要： {0}\n\
找到： {1}

## The first argument ({0}) is a "kindname".
compiler.err.cant.resolve=\
找不到符号\n\
符号： {0} {3}{1}{2}

## The first argument ({0}) and fifth argument ({4}) are "kindname"s.
compiler.err.cant.resolve.location=\
找不到符号\n\
符号： {0} {3}{1}{2}\n\
位置： {4} {5}

## The following are all possible string for "kindname".
## They should be called whatever the JLS calls them after it been translated
## to the appropriate language.
# compiler.misc.kindname.constructor=\
#     static member
compiler.misc.kindname.annotation=\
@interface
compiler.misc.kindname.constructor=\
构造函数
compiler.misc.kindname.interface=\
接口
compiler.misc.kindname.static=\
静态
compiler.misc.kindname.type.variable=\
类型变量的限制范围
compiler.misc.kindname=\
标识符 ({0})
compiler.misc.kindname.variable=\
变量
compiler.misc.kindname.value=\
值
compiler.misc.kindname.method=\
方法
compiler.misc.kindname.variable.method=\
变量、方法
compiler.misc.kindname.value.method=\
值、方法
compiler.misc.kindname.class=\
类
compiler.misc.kindname.variable.class=\
变量、类
compiler.misc.kindname.value.class=\
值、类
compiler.misc.kindname.method.class=\
方法、类
compiler.misc.kindname.variable.method.class=\
变量、方法、类
compiler.misc.kindname.value.method.class=\
值、方法、类
compiler.misc.kindname.package=\
软件包
compiler.misc.kindname.variable.package=\
变量、软件包
compiler.misc.kindname.value.package=\
值、软件包
compiler.misc.kindname.method.package=\
方法、软件包
compiler.misc.kindname.variable.method.package=\
变量、方法、软件包
compiler.misc.kindname.value.method.package=\
值、方法、软件包
compiler.misc.kindname.class.package=\
类、软件包
compiler.misc.kindname.variable.class.package=\
变量、类、软件包
compiler.misc.kindname.value.class.package=\
值、类、软件包
compiler.misc.kindname.method.class.package=\
方法、类、软件包
compiler.misc.kindname.variable.method.class.package=\
变量、方法、类、软件包
compiler.misc.kindname.value.method.class.package=\
值、方法、类、软件包

#####

compiler.err.override.static=\
{0}；覆盖的方法为静态
compiler.err.override.meth=\
{0}；被覆盖的方法为 {1}

compiler.err.override.meth.doesnt.throw=\
{0}；被覆盖的方法不抛出 {1}

# In the following string {1} is a space separated list of Java Keywords, as
# they would have been declared in the source code
compiler.err.override.weaker.access=\
{0}；正在尝试指定更低的访问权限；为 {1}

compiler.misc.override.incompatible.ret=\
{0}；正在尝试使用不兼容的返回类型

compiler.misc.override.unchecked.ret=\
{0}；返回类型需要未经检查的转换

## The following are all possible strings for the first argument ({0}) of the
## above strings.
compiler.misc.cant.override=\
{1} 中的 {0} 无法覆盖 {3} 中的 {2}
compiler.misc.cant.implement=\
{1} 中的 {0} 无法实现 {3} 中的 {2}
compiler.misc.clashes.with=\
{1} 中的 {0} 与 {3} 中的 {2} 冲突
compiler.misc.unchecked.override=\
{1} 中的 {0} 覆盖了 {3} 中的 {2}
compiler.misc.unchecked.implement=\
{1} 中的 {0} 实现了 {3} 中的 {2}
compiler.misc.unchecked.clash.with=\
{1} 中的 {0} 覆盖了 {3} 中的 {2}
compiler.misc.varargs.override=\
{1} 中的 {0} 覆盖了 {3} 中的 {2}
compiler.misc.varargs.implement=\
{1} 中的 {0} 实现了 {3} 中的 {2}
compiler.misc.varargs.clash.with=\
{1} 中的 {0} 覆盖了 {3} 中的 {2}

########################################
# Diagnostics for language feature changes
########################################
compiler.err.unsupported.fp.lit=\
在 -source 5 之前，不支持十六进制浮点字面值

compiler.warn.enum.as.identifier=\
从发行版 5 开始，"enum" 为关键字，而不用作标识符\n\
（请使用 -source 5 或更高版本以将 "enum"' 用作关键字）

compiler.warn.assert.as.identifier=\
从版本 1.4 开始，''assert'' 是一个关键字，但不能用作标识符\n\
（请使用 -source 1.4 或更高版本以便将 ''assert'' 用作关键字）

compiler.err.enum.as.identifier=\
从发行版 5 开始，"enum" 为关键字，而不用作标识符\n\
（请使用 -source 1.4 或更低版本以将 "enum" 用作标识符）

compiler.err.assert.as.identifier=\
从版本 1.4 开始，''assert'' 是一个关键字，但不能用作标识符\n\
（请使用 -source 1.3 或更低版本以便将 ''assert'' 用作标识符）

compiler.err.generics.not.supported.in.source=\
-source {0} 中不支持泛型\n\
（请使用 -source 5 或更高版本以启用泛型）

compiler.err.varargs.not.supported.in.source=\
-source {0} 中不支持 variable-arity 方法\n\
（请使用 -source 5 或更高版本以启用 variable-arity 方法）

compiler.err.annotations.not.supported.in.source=\
-source {0} 中不支持注释\n\
（请使用 -source 5 或更高版本以启用注释）

compiler.err.foreach.not.supported.in.source=\
-source {0} 中不支持 for-each 循环\n\
（请使用 -source 5 或更高版本以启用 for-each 循环）

compiler.err.static.import.not.supported.in.source=\
-source {0} 中不支持静态导入声明\n\
（请使用 -source 5 或更高版本以启用静态导入声明）

compiler.err.enums.not.supported.in.source=\
-source {0} 中不支持枚举\n\
（请使用 -source 5 或更高版本以启用枚举）
